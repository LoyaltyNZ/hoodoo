<!DOCTYPE html>

<html>
<head>
<meta charset="UTF-8">

<title>class ApiTools::ServiceMiddleware - ApiTools</title>

<link href="../fonts.css" rel="stylesheet">
<link href="../rdoc.css" rel="stylesheet">

<script type="text/javascript">
  var rdoc_rel_prefix = "../";
</script>

<script src="../js/jquery.js"></script>
<script src="../js/navigation.js"></script>
<script src="../js/search_index.js"></script>
<script src="../js/search.js"></script>
<script src="../js/searcher.js"></script>
<script src="../js/darkfish.js"></script>


<body id="top" role="document" class="class">
<nav role="navigation">
  <div id="project-navigation">
    <div id="home-section" role="region" title="Quick navigation" class="nav-section">
  <h2>
    <a href="../index.html" rel="home">Home</a>
  </h2>

  <div id="table-of-contents-navigation">
    <a href="../table_of_contents.html#pages">Pages</a>
    <a href="../table_of_contents.html#classes">Classes</a>
    <a href="../table_of_contents.html#methods">Methods</a>
  </div>
</div>

    <div id="search-section" role="search" class="project-section initially-hidden">
  <form action="#" method="get" accept-charset="utf-8">
    <div id="search-field-wrapper">
      <input id="search-field" role="combobox" aria-label="Search"
             aria-autocomplete="list" aria-controls="search-results"
             type="text" name="search" placeholder="Search" spellcheck="false"
             title="Type to search, Up and Down to navigate, Enter to load">
    </div>

    <ul id="search-results" aria-label="Search Results"
        aria-busy="false" aria-expanded="false"
        aria-atomic="false" class="initially-hidden"></ul>
  </form>
</div>

  </div>

  

  <div id="class-metadata">
    
    <div id="parent-class-section" class="nav-section">
  <h3>Parent</h3>

  
  <p class="link">Object
  
</div>

    
    
    <!-- Method Quickref -->
<div id="method-list-section" class="nav-section">
  <h3>Methods</h3>

  <ul class="link-list" role="directory">
    
    <li ><a href="#method-c-environment">::environment</a>
    
    <li ><a href="#method-c-has_memcache-3F">::has_memcache?</a>
    
    <li ><a href="#method-c-new">::new</a>
    
    <li ><a href="#method-c-on_queue-3F">::on_queue?</a>
    
    <li ><a href="#method-c-record_host_and_port">::record_host_and_port</a>
    
    <li ><a href="#method-i-call">#call</a>
    
    <li ><a href="#method-i-inter_service">#inter_service</a>
    
    <li ><a href="#method-i-inter_service_local">#inter_service_local</a>
    
    <li ><a href="#method-i-inter_service_remote">#inter_service_remote</a>
    
    <li ><a href="#method-i-local_service_for">#local_service_for</a>
    
    <li ><a href="#method-i-remote_service_for">#remote_service_for</a>
    
  </ul>
</div>

  </div>
</nav>

<main role="main" aria-labelledby="class-ApiTools::ServiceMiddleware">
  <h1 id="class-ApiTools::ServiceMiddleware" class="class">
    class ApiTools::ServiceMiddleware
  </h1>

  <section class="description">
    
<p>Rack middleware, declared in (e.g.) a <code>config.ru</code> file in the
usual way:</p>

<pre>use( ApiTools::ServiceMiddleware )</pre>

<p>This is the core of the common service implementation on the Rack
client-request-handling side. It is run in the context of an <a
href="ServiceApplication.html">ApiTools::ServiceApplication</a> subclass
that&#39;s been given to Rack as the Rack endpoint application; it looks at
the component interfaces supported by the service and routes requests to
the correct one (or raises a 404).</p>

<p>Lots of preprocessing and postprocessing gets done to set up things like
locale information, enforce content types and so-forth. Request data is
assembled in a parsed, structured format for passing to service
implementations and a response object built so that services have a
consistent way to return results, which can be post-processed further by
the middleware before returning the data to Rack.</p>

  </section>

  
  
  
  <section id="5Buntitled-5D" class="documentation-section">
    

    

    
    <section class="constants-list">
      <header>
        <h3>Constants</h3>
      </header>
      <dl>
      
        <dt id="ALLOWED_ACTIONS">ALLOWED_ACTIONS
        
        <dd><p>All allowed action names in implementations, used for internal checks. This
is also the default supported set of actions. Symbols.</p>
        
      
        <dt id="ALLOWED_QUERIES_ALL">ALLOWED_QUERIES_ALL
        
        <dd><p>Allowed common fields in query strings (all actions). Strings. Adds to the
::ALLOWED_QUERIES_LIST for list actions.</p>

<p>Only ever <strong>add</strong> to this list. As the API evolves, legacy
clients will be calling with previously documented query strings and
removing any entries from the list below could cause their requests to be
rejected with a &#39;platform.malformed&#39; error.</p>
        
      
        <dt id="ALLOWED_QUERIES_LIST">ALLOWED_QUERIES_LIST
        
        <dd><p>Allowed common fields in query strings (list actions only). Strings.</p>

<p>Only ever <strong>add</strong> to this list. As the API evolves, legacy
clients will be calling with previously documented query strings and
removing any entries from the list below could cause their requests to be
rejected with a &#39;platform.malformed&#39; error.</p>
        
      
        <dt id="FRONT_OBJECT">FRONT_OBJECT
        
        <dd><p>Singleton “Front object” for the DRB service used in local development.</p>
        
      
        <dt id="MAXIMUM_PAYLOAD_SIZE">MAXIMUM_PAYLOAD_SIZE
        
        <dd><p>Somewhat arbitrary maximum incoming payload size to prevent ham-fisted DOS
attempts to consume RAM.</p>
        
      
        <dt id="SUPPORTED_ENCODINGS">SUPPORTED_ENCODINGS
        
        <dd><p>Allowed (required) charsets in Content-Type headers.</p>
        
      
        <dt id="SUPPORTED_MEDIA_TYPES">SUPPORTED_MEDIA_TYPES
        
        <dd><p>Allowed media types in Content-Type headers.</p>
        
      
      </dl>
    </section>
    

    

    
     <section id="public-class-5Buntitled-5D-method-details" class="method-section">
       <header>
         <h3>Public Class Methods</h3>
       </header>

    
      <div id="method-c-environment" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">environment</span><span
            class="method-args">()</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Utility - returns the execution environment as a Rails-like environment
object which answers queries like <code>production?</code> or
<code>staging?</code> with <code>true</code> or <code>false</code>
according to the <code>RACK_ENV</code> environment variable setting.</p>

<p>Example:</p>

<pre>if ApiTools::ServiceMiddleware.environment.production?
  # ...do something only if RACK_ENV=&quot;production&quot;
end</pre>
          
          

          
          <div class="method-source-code" id="environment-source">
            <pre><span class="ruby-comment"># File lib/api_tools/service_middleware/service_middleware.rb, line 105</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">environment</span>
  <span class="ruby-ivar">@_env</span> <span class="ruby-operator">||=</span> <span class="ruby-constant">ApiTools</span><span class="ruby-operator">::</span><span class="ruby-constant">StringInquirer</span>.<span class="ruby-identifier">new</span>( <span class="ruby-constant">ENV</span>[ <span class="ruby-string">&#39;RACK_ENV&#39;</span> ] <span class="ruby-operator">||</span> <span class="ruby-string">&#39;development&#39;</span> )
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-c-has_memcache-3F" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">has_memcache?</span><span
            class="method-args">()</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Do we have Memcache available? If not, assume local development with higher
level queue services not available. Most service authors should not ever
need to check this.</p>
          
          

          
          <div class="method-source-code" id="has_memcache-3F-source">
            <pre><span class="ruby-comment"># File lib/api_tools/service_middleware/service_middleware.rb, line 113</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">has_memcache?</span>
  <span class="ruby-identifier">m</span> = <span class="ruby-constant">ENV</span>[ <span class="ruby-string">&#39;MEMCACHE_URL&#39;</span> ]
  <span class="ruby-identifier">m</span>.<span class="ruby-identifier">nil?</span> <span class="ruby-operator">==</span> <span class="ruby-keyword">false</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">m</span>.<span class="ruby-identifier">empty?</span> <span class="ruby-operator">==</span> <span class="ruby-keyword">false</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-c-new" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">new</span><span
            class="method-args">( app )</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Initialize the middleware instance.</p>

<p><code>app</code> Rack app instance to which calls should be passed.</p>
          
          

          
          <div class="method-source-code" id="new-source">
            <pre><span class="ruby-comment"># File lib/api_tools/service_middleware/service_middleware.rb, line 141</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">initialize</span>( <span class="ruby-identifier">app</span> )

  <span class="ruby-ivar">@service_container</span> = <span class="ruby-identifier">app</span>

  <span class="ruby-keyword">unless</span> <span class="ruby-ivar">@service_container</span>.<span class="ruby-identifier">is_a?</span>( <span class="ruby-constant">ApiTools</span><span class="ruby-operator">::</span><span class="ruby-constant">ServiceApplication</span> )
    <span class="ruby-identifier">raise</span> <span class="ruby-node">&quot;ApiTools::ServiceMiddleware instance created with non-ServiceApplication entity of class &#39;#{ app.class }&#39; - is this the last middleware in the chain via &#39;use()&#39; and is Rack &#39;run()&#39;-ing the correct thing?&quot;</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># Collect together the implementation instances and the matching regexps</span>
  <span class="ruby-comment"># for endpoints. An array of hashes.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># Key              Value</span>
  <span class="ruby-comment"># =======================================================================</span>
  <span class="ruby-comment"># regexp           Regexp for +String#match+ on the URI path component</span>
  <span class="ruby-comment"># interface        ApiTools::ServiceInterface subclass associated with</span>
  <span class="ruby-comment">#                  the endpoint regular expression in +regexp+</span>
  <span class="ruby-comment"># actions          Array of symbols naming allowed actions</span>
  <span class="ruby-comment"># implementation   ApiTools::ServiceImplementation subclass *instance* to</span>
  <span class="ruby-comment">#                  use on match</span>

  <span class="ruby-ivar">@services</span> = <span class="ruby-ivar">@service_container</span>.<span class="ruby-identifier">component_interfaces</span>.<span class="ruby-identifier">map</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span> <span class="ruby-identifier">interface</span> <span class="ruby-operator">|</span>

    <span class="ruby-keyword">if</span> <span class="ruby-identifier">interface</span>.<span class="ruby-identifier">nil?</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">interface</span>.<span class="ruby-identifier">endpoint</span>.<span class="ruby-identifier">nil?</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">interface</span>.<span class="ruby-identifier">implementation</span>.<span class="ruby-identifier">nil?</span>
      <span class="ruby-identifier">raise</span> <span class="ruby-node">&quot;ApiTools::ServiceMiddleware encountered invalid interface class #{ interface } via service class #{ app.class }&quot;</span>
    <span class="ruby-keyword">end</span>

    <span class="ruby-comment"># Regexp explanation:</span>
    <span class="ruby-comment">#</span>
    <span class="ruby-comment"># Match &quot;/&quot;, the version text, &quot;/&quot;, the endpoint text, then either</span>
    <span class="ruby-comment"># another &quot;/&quot;, a &quot;.&quot; or the end of the string, followed by capturing</span>
    <span class="ruby-comment"># everything else. Match data index 1 will be whatever character (if</span>
    <span class="ruby-comment"># any) followed after the endpoint (&quot;/&quot; or &quot;.&quot;) while index 2 contains</span>
    <span class="ruby-comment"># everything else.</span>

    {
      <span class="ruby-value">:regexp</span>         =<span class="ruby-operator">&gt;</span> <span class="ruby-node">/\/v#{ interface.version }\/#{ interface.endpoint }(\.|\/|$)(.*)/</span>,
      <span class="ruby-value">:path</span>           =<span class="ruby-operator">&gt;</span> <span class="ruby-node">&quot;/v#{ interface.version }/#{ interface.endpoint }&quot;</span>,
      <span class="ruby-value">:interface</span>      =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">interface</span>,
      <span class="ruby-value">:implementation</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">interface</span>.<span class="ruby-identifier">implementation</span>.<span class="ruby-identifier">new</span>
    }

  <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">announce_presence_of</span>( <span class="ruby-ivar">@services</span> )
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-c-on_queue-3F" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">on_queue?</span><span
            class="method-args">()</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Are we running on the queue, else (implied) a local HTTP server?</p>
          
          

          
          <div class="method-source-code" id="on_queue-3F-source">
            <pre><span class="ruby-comment"># File lib/api_tools/service_middleware/service_middleware.rb, line 120</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">on_queue?</span>
  <span class="ruby-identifier">q</span> = <span class="ruby-constant">ENV</span>[ <span class="ruby-string">&#39;AMQ_ENDPOINT&#39;</span> ]
  <span class="ruby-identifier">q</span>.<span class="ruby-identifier">nil?</span> <span class="ruby-operator">==</span> <span class="ruby-keyword">false</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">q</span>.<span class="ruby-identifier">empty?</span> <span class="ruby-operator">==</span> <span class="ruby-keyword">false</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-c-record_host_and_port" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">record_host_and_port</span><span
            class="method-args">( options = {} )</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Record internally the HTTP host and port during local development via e.g
<code>rackup</code> or testing with rspec. This is usually not called
directly except via the Rack startup monkey patch code in
<code>rack_monkey_patch.rb</code>.</p>

<p>Options hash <code>:Host</code> and <code>:Port</code> entries are
recorded.</p>
          
          

          
          <div class="method-source-code" id="record_host_and_port-source">
            <pre><span class="ruby-comment"># File lib/api_tools/service_middleware/service_middleware.rb, line 132</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">record_host_and_port</span>( <span class="ruby-identifier">options</span> = {} )
  <span class="ruby-identifier">@@recorded_host</span> = <span class="ruby-identifier">options</span>[ <span class="ruby-value">:Host</span> ]
  <span class="ruby-identifier">@@recorded_port</span> = <span class="ruby-identifier">options</span>[ <span class="ruby-value">:Port</span> ]
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
    </section>
  
     <section id="public-instance-5Buntitled-5D-method-details" class="method-section">
       <header>
         <h3>Public Instance Methods</h3>
       </header>

    
      <div id="method-i-call" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">call</span><span
            class="method-args">( env )</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Run a Rack request, returning the [status, headers, body-array] data as per
the Rack protocol requirements.</p>

<p><code>env</code> Rack environment.</p>
          
          

          
          <div class="method-source-code" id="call-source">
            <pre><span class="ruby-comment"># File lib/api_tools/service_middleware/service_middleware.rb, line 192</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">call</span>( <span class="ruby-identifier">env</span> )

  <span class="ruby-comment"># Global exception handler - catch problems in service implementations</span>
  <span class="ruby-comment"># and send back a 500 response as per API documentation (if possible).</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-keyword">begin</span>

    <span class="ruby-ivar">@interaction_id</span> = <span class="ruby-ivar">@session_id</span> = <span class="ruby-keyword">nil</span>

    <span class="ruby-constant">ApiTools</span><span class="ruby-operator">::</span><span class="ruby-constant">Logger</span>.<span class="ruby-identifier">send</span>(
      <span class="ruby-value">:debug</span>,
      <span class="ruby-string">&#39;ApiTools::ServiceMiddleware#call with Rack &quot;env&quot;:&#39;</span>,
      <span class="ruby-identifier">env</span>.<span class="ruby-identifier">inspect</span>
    )

    <span class="ruby-ivar">@rack_request</span> = <span class="ruby-constant">Rack</span><span class="ruby-operator">::</span><span class="ruby-constant">Request</span>.<span class="ruby-identifier">new</span>( <span class="ruby-identifier">env</span> )

    <span class="ruby-identifier">log</span>( <span class="ruby-value">:info</span> )

    <span class="ruby-ivar">@service_response</span> = <span class="ruby-constant">ApiTools</span><span class="ruby-operator">::</span><span class="ruby-constant">ServiceResponse</span>.<span class="ruby-identifier">new</span>

    <span class="ruby-identifier">load_session</span>()
    <span class="ruby-identifier">preprocess</span>()  <span class="ruby-keyword">unless</span> <span class="ruby-ivar">@service_response</span>.<span class="ruby-identifier">halt_processing?</span>
    <span class="ruby-identifier">process</span>()     <span class="ruby-keyword">unless</span> <span class="ruby-ivar">@service_response</span>.<span class="ruby-identifier">halt_processing?</span>
    <span class="ruby-identifier">postprocess</span>() <span class="ruby-keyword">unless</span> <span class="ruby-ivar">@service_response</span>.<span class="ruby-identifier">halt_processing?</span>

    <span class="ruby-keyword">return</span> <span class="ruby-identifier">respond_with</span>( <span class="ruby-ivar">@service_response</span>.<span class="ruby-identifier">for_rack</span>() )

  <span class="ruby-keyword">rescue</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">exception</span>
    <span class="ruby-keyword">begin</span>
      <span class="ruby-keyword">return</span> <span class="ruby-identifier">respond_with</span>( <span class="ruby-identifier">record_exception</span>( <span class="ruby-ivar">@service_response</span>, <span class="ruby-identifier">exception</span> ) )

    <span class="ruby-keyword">rescue</span>

      <span class="ruby-keyword">begin</span>
        <span class="ruby-constant">ApiTools</span><span class="ruby-operator">::</span><span class="ruby-constant">Logger</span>.<span class="ruby-identifier">error</span>(
          <span class="ruby-string">&#39;ApiTools::ServiceMiddleware#call&#39;</span>,
          <span class="ruby-string">&#39;Middleware exception in exception handler&#39;</span>,
          <span class="ruby-identifier">exception</span>.<span class="ruby-identifier">to_s</span>
        )
      <span class="ruby-keyword">rescue</span>
        <span class="ruby-comment"># Ignore logger exceptions. Can&#39;t do anything about them. Just</span>
        <span class="ruby-comment"># try and get the response back to the client now.</span>
      <span class="ruby-keyword">end</span>

      <span class="ruby-comment"># An exception in the exception handler! Oh dear.</span>
      <span class="ruby-comment">#</span>
      <span class="ruby-keyword">return</span> [
        <span class="ruby-value">500</span>, {}, <span class="ruby-constant">Rack</span><span class="ruby-operator">::</span><span class="ruby-constant">BodyProxy</span>.<span class="ruby-identifier">new</span>( [ <span class="ruby-string">&#39;Middleware exception in exception handler&#39;</span> ] ) {}
      ]

    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
    </section>
  
     <section id="protected-instance-5Buntitled-5D-method-details" class="method-section">
       <header>
         <h3>Protected Instance Methods</h3>
       </header>

    
      <div id="method-i-inter_service" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">inter_service</span><span
            class="method-args">( options )</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Perform an inter-service call. This shouldn&#39;t be called directly; call
via the <a
href="ServiceMiddleware/ServiceEndpoint.html">ApiTools::ServiceMiddleware::ServiceEndpoint</a>
subclass specialised methods instead, which makes sure it sets up the
required parameters in correct combinations. Undefined results will arise
for incorrect calls.</p>
<dl class="rdoc-list note-list"><dt><code>options</code>
<dd>
<p>Options hash with keys and required values described below.</p>
</dd></dl>

<p>Options are as follows - keys must be Symbols:</p>
<dl class="rdoc-list note-list"><dt><code>local</code>
<dd>
<p>A +@services+ entry (see implementation of initialize) describing the
service to call if local, else <code>nil</code> or absent.</p>
</dd><dt><code>remote</code>
<dd>
<p>A URI as a String for a remote service endpoint, else <code>nil</code> or
absent.</p>
</dd><dt><code>resource</code>
<dd>
<p>The String or Symbol resource name, e.g. “Product”.</p>
</dd><dt><code>version</code>
<dd>
<p>The Integer endpoint API version, e.g. 2.</p>
</dd><dt><code>http_method</code>
<dd>
<p>HTTP method as a String, e.g. “<code>GET</code>”, “<code>DELETE</code>”.</p>
</dd><dt><code>ident</code>
<dd>
<p>ID / <a href="UUID.html">UUID</a> / similar; first and only path component.</p>
</dd><dt><code>query_hash</code>
<dd>
<p>Converted to query string.</p>
</dd><dt><code>body_hash</code>
<dd>
<p>Converted to body data.</p>
</dd></dl>

<p>Parameters should be nil where the value would not be allowed given the
HTTP method. HTTP methods must map to understood actions.</p>

<p>@service_response is updated on exit. If this says “halt processing”,
errors were generated. Ignore the function return value. Otherwise, returns
a Has equivalent of the JSON resource representation in the non-list-action
cases, else an array of zero or more JSON resource representations in the
list action case.</p>
          
          

          
          <div class="method-source-code" id="inter_service-source">
            <pre><span class="ruby-comment"># File lib/api_tools/service_middleware/service_middleware.rb, line 1115</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">inter_service</span>( <span class="ruby-identifier">options</span> )

  <span class="ruby-identifier">remote</span> = <span class="ruby-identifier">options</span>[ <span class="ruby-value">:local</span> ].<span class="ruby-identifier">nil?</span>

  <span class="ruby-identifier">log</span>(
    <span class="ruby-value">:debug</span>,
    <span class="ruby-node">&quot;#{ remote ? &#39;Remote&#39; : &#39;Local&#39; } inter-service call requested with options #{ options }&quot;</span>
  )

  <span class="ruby-keyword">if</span> ( <span class="ruby-identifier">remote</span> )
    <span class="ruby-identifier">result</span> = <span class="ruby-identifier">inter_service_remote</span>( <span class="ruby-identifier">options</span> )
  <span class="ruby-keyword">else</span>
    <span class="ruby-identifier">result</span> = <span class="ruby-identifier">inter_service_local</span>( <span class="ruby-identifier">options</span> )
  <span class="ruby-keyword">end</span>

  <span class="ruby-keyword">if</span> <span class="ruby-ivar">@service_response</span>.<span class="ruby-identifier">halt_processing?</span>
    <span class="ruby-identifier">log</span>(
      <span class="ruby-value">:warn</span>,
      <span class="ruby-node">&quot;#{ remote ? &#39;Remote&#39; : &#39;Local&#39; } inter-service call halted processing with errors #{ @service_response.errors.errors }&quot;</span>
    )
  <span class="ruby-keyword">else</span>
    <span class="ruby-identifier">log</span>(
      <span class="ruby-value">:debug</span>,
      <span class="ruby-node">&quot;#{ remote ? &#39;Remote&#39; : &#39;Local&#39; } inter-service call succeeded with result &#39;#{ result }&#39;&quot;</span>
    )
  <span class="ruby-keyword">end</span>

  <span class="ruby-keyword">return</span> <span class="ruby-identifier">result</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-inter_service_local" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">inter_service_local</span><span
            class="method-args">( options )</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Make a local (non-HTTP local Ruby method call) inter-service call. Fast.</p>
<dl class="rdoc-list note-list"><dt><code>options</code>
<dd>
<p>See <a
href="ServiceMiddleware.html#method-i-inter_service">inter_service</a>.</p>
</dd><dt>Returns
<dd>
<p>See <a
href="ServiceMiddleware.html#method-i-inter_service">inter_service</a>.</p>
</dd></dl>
          
          

          
          <div class="method-source-code" id="inter_service_local-source">
            <pre><span class="ruby-comment"># File lib/api_tools/service_middleware/service_middleware.rb, line 1292</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">inter_service_local</span>( <span class="ruby-identifier">options</span> )
  <span class="ruby-identifier">service</span>        = <span class="ruby-identifier">options</span>[ <span class="ruby-value">:local</span>       ]
  <span class="ruby-identifier">http_method</span>    = <span class="ruby-identifier">options</span>[ <span class="ruby-value">:http_method</span> ]
  <span class="ruby-identifier">ident</span>          = <span class="ruby-identifier">options</span>[ <span class="ruby-value">:ident</span>       ]
  <span class="ruby-identifier">body_hash</span>      = <span class="ruby-identifier">options</span>[ <span class="ruby-value">:body_hash</span>   ]
  <span class="ruby-identifier">query_hash</span>     = <span class="ruby-identifier">options</span>[ <span class="ruby-value">:query_hash</span>  ]

  <span class="ruby-identifier">interface</span>      = <span class="ruby-identifier">service</span>[ <span class="ruby-value">:interface</span>      ]
  <span class="ruby-identifier">actions</span>        = <span class="ruby-identifier">service</span>[ <span class="ruby-value">:actions</span>        ]
  <span class="ruby-identifier">implementation</span> = <span class="ruby-identifier">service</span>[ <span class="ruby-value">:implementation</span> ]


  <span class="ruby-comment"># We must construct a call context for the local service. This means</span>
  <span class="ruby-comment"># a local request object which we fill in with data just as if we&#39;d</span>
  <span class="ruby-comment"># parsed an inbound HTTP request and a response object that contains</span>
  <span class="ruby-comment"># the usual default data.</span>

  <span class="ruby-identifier">local_service_response</span> = <span class="ruby-constant">ApiTools</span><span class="ruby-operator">::</span><span class="ruby-constant">ServiceResponse</span>.<span class="ruby-identifier">new</span>
  <span class="ruby-identifier">set_common_response_headers</span>( <span class="ruby-identifier">local_service_response</span> )
  <span class="ruby-identifier">update_service_response_for</span>( <span class="ruby-identifier">local_service_response</span>, <span class="ruby-identifier">interface</span> )

  <span class="ruby-identifier">upc</span>  = []
  <span class="ruby-identifier">upc</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">ident</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">ident</span>.<span class="ruby-identifier">nil?</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">ident</span>.<span class="ruby-identifier">empty?</span>

  <span class="ruby-identifier">action</span> = <span class="ruby-identifier">determine_action</span>(
    <span class="ruby-identifier">interface</span>,
    <span class="ruby-identifier">http_method</span>,
    <span class="ruby-identifier">upc</span>.<span class="ruby-identifier">empty?</span>,
    <span class="ruby-identifier">local_service_response</span>
  )

  <span class="ruby-keyword">if</span> <span class="ruby-identifier">local_service_response</span>.<span class="ruby-identifier">halt_processing?</span>
    <span class="ruby-ivar">@service_response</span>.<span class="ruby-identifier">errors</span>.<span class="ruby-identifier">merge!</span>( <span class="ruby-identifier">local_service_response</span>.<span class="ruby-identifier">errors</span> )
    <span class="ruby-keyword">return</span> <span class="ruby-keyword">nil</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">local_service_request</span>                     = <span class="ruby-identifier">new_service_request_for</span>( <span class="ruby-identifier">interface</span> )
  <span class="ruby-identifier">local_service_request</span>.<span class="ruby-identifier">uri_path_components</span> = <span class="ruby-identifier">upc</span>
  <span class="ruby-identifier">local_service_request</span>.<span class="ruby-identifier">uri_path_extension</span>  = <span class="ruby-string">&#39;&#39;</span>

  <span class="ruby-keyword">unless</span> <span class="ruby-identifier">query_hash</span>.<span class="ruby-identifier">nil?</span>
    <span class="ruby-identifier">query_hash</span> = <span class="ruby-constant">ApiTools</span><span class="ruby-operator">::</span><span class="ruby-constant">Utilities</span>.<span class="ruby-identifier">stringify</span>( <span class="ruby-identifier">query_hash</span> )

    <span class="ruby-comment"># This is for inter-service local calls where a service author</span>
    <span class="ruby-comment"># specifies &quot;:_embed =&gt; &#39;foo&#39;&quot; accidentally, forgetting that it</span>
    <span class="ruby-comment"># should be a single element array. It&#39;s such a common mistake</span>
    <span class="ruby-comment"># that we tolerate it here. Same for &quot;_reference&quot;.</span>

    <span class="ruby-identifier">data</span> = <span class="ruby-identifier">query_hash</span>[ <span class="ruby-string">&#39;_embed&#39;</span> ]
    <span class="ruby-identifier">query_hash</span>[ <span class="ruby-string">&#39;_embed&#39;</span> ] = [ <span class="ruby-identifier">data</span> ] <span class="ruby-keyword">if</span> <span class="ruby-identifier">data</span>.<span class="ruby-identifier">is_a?</span>( <span class="ruby-operator">::</span><span class="ruby-constant">String</span> ) <span class="ruby-operator">||</span> <span class="ruby-identifier">data</span>.<span class="ruby-identifier">is_a?</span>( <span class="ruby-operator">::</span><span class="ruby-constant">Symbol</span> )

    <span class="ruby-identifier">data</span> = <span class="ruby-identifier">query_hash</span>[ <span class="ruby-string">&#39;_reference&#39;</span> ]
    <span class="ruby-identifier">query_hash</span>[ <span class="ruby-string">&#39;_reference&#39;</span> ] = [ <span class="ruby-identifier">data</span> ] <span class="ruby-keyword">if</span> <span class="ruby-identifier">data</span>.<span class="ruby-identifier">is_a?</span>( <span class="ruby-operator">::</span><span class="ruby-constant">String</span> ) <span class="ruby-operator">||</span> <span class="ruby-identifier">data</span>.<span class="ruby-identifier">is_a?</span>( <span class="ruby-operator">::</span><span class="ruby-constant">Symbol</span> )

    <span class="ruby-comment"># Regardless, make sure embed/reference array data contains strings.</span>

    <span class="ruby-identifier">query_hash</span>[ <span class="ruby-string">&#39;_embed&#39;</span>     ].<span class="ruby-identifier">map!</span>( <span class="ruby-operator">&amp;</span><span class="ruby-value">:to_s</span> ) <span class="ruby-keyword">unless</span> <span class="ruby-identifier">query_hash</span>[ <span class="ruby-string">&#39;_embed&#39;</span>     ].<span class="ruby-identifier">nil?</span>
    <span class="ruby-identifier">query_hash</span>[ <span class="ruby-string">&#39;_reference&#39;</span> ].<span class="ruby-identifier">map!</span>( <span class="ruby-operator">&amp;</span><span class="ruby-value">:to_s</span> ) <span class="ruby-keyword">unless</span> <span class="ruby-identifier">query_hash</span>[ <span class="ruby-string">&#39;_reference&#39;</span> ].<span class="ruby-identifier">nil?</span>

    <span class="ruby-identifier">process_query_hash</span>(
      <span class="ruby-identifier">action</span>,
      <span class="ruby-identifier">query_hash</span>,
      <span class="ruby-identifier">interface</span>,
      <span class="ruby-identifier">local_service_request</span>,
      <span class="ruby-identifier">local_service_response</span>
    )
  <span class="ruby-keyword">end</span>

  <span class="ruby-keyword">if</span> <span class="ruby-identifier">local_service_response</span>.<span class="ruby-identifier">halt_processing?</span>
    <span class="ruby-ivar">@service_response</span>.<span class="ruby-identifier">errors</span>.<span class="ruby-identifier">merge!</span>( <span class="ruby-identifier">local_service_response</span>.<span class="ruby-identifier">errors</span> )
    <span class="ruby-keyword">return</span> <span class="ruby-keyword">nil</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">local_service_request</span>.<span class="ruby-identifier">body</span> = <span class="ruby-identifier">body_hash</span>

  <span class="ruby-comment"># Dispatch the call, merge any errors that might have come back and</span>
  <span class="ruby-comment"># return the body of the called service&#39;s response.</span>

  <span class="ruby-identifier">log</span>(
    <span class="ruby-value">:debug</span>,
    <span class="ruby-node">&quot;Dispatching local inter-service call with parsed body data: &#39;#{ local_service_request.body }&#39;&quot;</span>
  )

  <span class="ruby-identifier">context</span> = <span class="ruby-constant">ApiTools</span><span class="ruby-operator">::</span><span class="ruby-constant">ServiceContext</span>.<span class="ruby-identifier">new</span>(
    <span class="ruby-ivar">@service_session</span>,
    <span class="ruby-identifier">local_service_request</span>,
    <span class="ruby-identifier">local_service_response</span>,
    <span class="ruby-keyword">self</span>
  )

  <span class="ruby-identifier">implementation</span>.<span class="ruby-identifier">send</span>( <span class="ruby-identifier">action</span>, <span class="ruby-identifier">context</span> )
  <span class="ruby-ivar">@service_response</span>.<span class="ruby-identifier">errors</span>.<span class="ruby-identifier">merge!</span>( <span class="ruby-identifier">local_service_response</span>.<span class="ruby-identifier">errors</span> )

  <span class="ruby-keyword">return</span> <span class="ruby-identifier">local_service_response</span>.<span class="ruby-identifier">body</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-inter_service_remote" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">inter_service_remote</span><span
            class="method-args">( options )</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Make a remote (HTTP) inter-service call. Slow.</p>
<dl class="rdoc-list note-list"><dt><code>options</code>
<dd>
<p>See <a
href="ServiceMiddleware.html#method-i-inter_service">inter_service</a>.</p>
</dd><dt>Returns
<dd>
<p>See <a
href="ServiceMiddleware.html#method-i-inter_service">inter_service</a>.</p>
</dd></dl>
          
          

          
          <div class="method-source-code" id="inter_service_remote-source">
            <pre><span class="ruby-comment"># File lib/api_tools/service_middleware/service_middleware.rb, line 1151</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">inter_service_remote</span>( <span class="ruby-identifier">options</span> )
  <span class="ruby-identifier">remote_uri</span>  = <span class="ruby-identifier">options</span>[ <span class="ruby-value">:remote</span>      ]
  <span class="ruby-identifier">http_method</span> = <span class="ruby-identifier">options</span>[ <span class="ruby-value">:http_method</span> ]
  <span class="ruby-identifier">ident</span>       = <span class="ruby-identifier">options</span>[ <span class="ruby-value">:ident</span>       ]
  <span class="ruby-identifier">body_hash</span>   = <span class="ruby-identifier">options</span>[ <span class="ruby-value">:body_hash</span>   ]
  <span class="ruby-identifier">query_hash</span>  = <span class="ruby-identifier">options</span>[ <span class="ruby-value">:query_hash</span>  ]

  <span class="ruby-comment"># Add a 404 error to the response (via a Proc for internal reuse).</span>

  <span class="ruby-identifier">add_404</span> = <span class="ruby-constant">Proc</span>.<span class="ruby-identifier">new</span> {
    <span class="ruby-ivar">@service_response</span>.<span class="ruby-identifier">add_error</span>(
      <span class="ruby-string">&#39;platform.not_found&#39;</span>,
      <span class="ruby-string">&#39;reference&#39;</span> =<span class="ruby-operator">&gt;</span> { <span class="ruby-value">:entity_name</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-node">&quot;v#{ options[ :version ] } of #{ options[ :resource ] } interface endpoint&quot;</span> }
    )
  }

  <span class="ruby-comment"># No endpoint found? Yikes!</span>

  <span class="ruby-keyword">if</span> ( <span class="ruby-identifier">remote_uri</span>.<span class="ruby-identifier">nil?</span> )
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">add_404</span>.<span class="ruby-identifier">call</span>()

  <span class="ruby-keyword">else</span>
    <span class="ruby-identifier">remote_uri</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-node">&quot;/#{ URI::escape( ident ) }&quot;</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">ident</span>.<span class="ruby-identifier">nil?</span>

  <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># Grey area over whether this encodes spaces as &quot;%20&quot; or &quot;+&quot;, but so</span>
  <span class="ruby-comment"># long as the middleware consistently uses the URI encode/decode calls,</span>
  <span class="ruby-comment"># it should work out in the end anyway.</span>

  <span class="ruby-keyword">unless</span> <span class="ruby-identifier">query_hash</span>.<span class="ruby-identifier">nil?</span>
    <span class="ruby-identifier">query_hash</span> = <span class="ruby-identifier">query_hash</span>.<span class="ruby-identifier">dup</span>
    <span class="ruby-identifier">query_hash</span>[ <span class="ruby-string">&#39;search&#39;</span> ] = <span class="ruby-constant">URI</span>.<span class="ruby-identifier">encode_www_form</span>( <span class="ruby-identifier">query_hash</span>[ <span class="ruby-string">&#39;search&#39;</span> ] ) <span class="ruby-keyword">if</span> ( <span class="ruby-identifier">query_hash</span>[ <span class="ruby-string">&#39;search&#39;</span> ].<span class="ruby-identifier">is_a?</span>( <span class="ruby-operator">::</span><span class="ruby-constant">Hash</span> ) )
    <span class="ruby-identifier">query_hash</span>[ <span class="ruby-string">&#39;filter&#39;</span> ] = <span class="ruby-constant">URI</span>.<span class="ruby-identifier">encode_www_form</span>( <span class="ruby-identifier">query_hash</span>[ <span class="ruby-string">&#39;filter&#39;</span> ] ) <span class="ruby-keyword">if</span> ( <span class="ruby-identifier">query_hash</span>[ <span class="ruby-string">&#39;filter&#39;</span> ].<span class="ruby-identifier">is_a?</span>( <span class="ruby-operator">::</span><span class="ruby-constant">Hash</span> ) )

    <span class="ruby-identifier">query_hash</span>[ <span class="ruby-string">&#39;_embed&#39;</span>     ] = <span class="ruby-identifier">query_hash</span>[ <span class="ruby-string">&#39;_embed&#39;</span>     ].<span class="ruby-identifier">join</span>( <span class="ruby-string">&#39;,&#39;</span> ) <span class="ruby-keyword">if</span> ( <span class="ruby-identifier">query_hash</span>[ <span class="ruby-string">&#39;_embed&#39;</span>     ].<span class="ruby-identifier">is_a?</span>( <span class="ruby-operator">::</span><span class="ruby-constant">Array</span> ) )
    <span class="ruby-identifier">query_hash</span>[ <span class="ruby-string">&#39;_reference&#39;</span> ] = <span class="ruby-identifier">query_hash</span>[ <span class="ruby-string">&#39;_reference&#39;</span> ].<span class="ruby-identifier">join</span>( <span class="ruby-string">&#39;,&#39;</span> ) <span class="ruby-keyword">if</span> ( <span class="ruby-identifier">query_hash</span>[ <span class="ruby-string">&#39;_reference&#39;</span> ].<span class="ruby-identifier">is_a?</span>( <span class="ruby-operator">::</span><span class="ruby-constant">Array</span> ) )

    <span class="ruby-identifier">query_hash</span>.<span class="ruby-identifier">delete</span>( <span class="ruby-string">&#39;search&#39;</span>     ) <span class="ruby-keyword">if</span> <span class="ruby-identifier">query_hash</span>[ <span class="ruby-string">&#39;search&#39;</span>     ].<span class="ruby-identifier">nil?</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">query_hash</span>[ <span class="ruby-string">&#39;search&#39;</span>     ].<span class="ruby-identifier">empty?</span>
    <span class="ruby-identifier">query_hash</span>.<span class="ruby-identifier">delete</span>( <span class="ruby-string">&#39;filter&#39;</span>     ) <span class="ruby-keyword">if</span> <span class="ruby-identifier">query_hash</span>[ <span class="ruby-string">&#39;filter&#39;</span>     ].<span class="ruby-identifier">nil?</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">query_hash</span>[ <span class="ruby-string">&#39;filter&#39;</span>     ].<span class="ruby-identifier">empty?</span>
    <span class="ruby-identifier">query_hash</span>.<span class="ruby-identifier">delete</span>( <span class="ruby-string">&#39;_embed&#39;</span>     ) <span class="ruby-keyword">if</span> <span class="ruby-identifier">query_hash</span>[ <span class="ruby-string">&#39;_embed&#39;</span>     ].<span class="ruby-identifier">nil?</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">query_hash</span>[ <span class="ruby-string">&#39;_embed&#39;</span>     ].<span class="ruby-identifier">empty?</span>
    <span class="ruby-identifier">query_hash</span>.<span class="ruby-identifier">delete</span>( <span class="ruby-string">&#39;_reference&#39;</span> ) <span class="ruby-keyword">if</span> <span class="ruby-identifier">query_hash</span>[ <span class="ruby-string">&#39;_reference&#39;</span> ].<span class="ruby-identifier">nil?</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">query_hash</span>[ <span class="ruby-string">&#39;_reference&#39;</span> ].<span class="ruby-identifier">empty?</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-keyword">unless</span> <span class="ruby-identifier">query_hash</span>.<span class="ruby-identifier">nil?</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">query_hash</span>.<span class="ruby-identifier">empty?</span>
    <span class="ruby-identifier">remote_uri</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-string">&#39;?&#39;</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-constant">URI</span>.<span class="ruby-identifier">encode_www_form</span>( <span class="ruby-identifier">query_hash</span> )
  <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">body_data</span> = <span class="ruby-identifier">body_hash</span>.<span class="ruby-identifier">nil?</span> <span class="ruby-operator">?</span> <span class="ruby-string">&#39;&#39;</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">body_hash</span>.<span class="ruby-identifier">to_json</span>
  <span class="ruby-identifier">headers</span>   = {
    <span class="ruby-string">&#39;Content-Type&#39;</span>     =<span class="ruby-operator">&gt;</span> <span class="ruby-string">&#39;application/json; charset=utf-8&#39;</span>,
    <span class="ruby-string">&#39;Content-Language&#39;</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-ivar">@locale</span>,
    <span class="ruby-string">&#39;X-Interaction-ID&#39;</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-ivar">@interaction_id</span> <span class="ruby-operator">||</span> <span class="ruby-string">&#39;+&#39;</span>,
    <span class="ruby-string">&#39;X-Session-ID&#39;</span>     =<span class="ruby-operator">&gt;</span> <span class="ruby-ivar">@session_id</span>     <span class="ruby-operator">||</span> <span class="ruby-string">&#39;+&#39;</span>
  }

  <span class="ruby-comment"># Drive the HTTP library using the data assembled above</span>

  <span class="ruby-identifier">remote_uri</span> = <span class="ruby-constant">URI</span>.<span class="ruby-identifier">parse</span>( <span class="ruby-identifier">remote_uri</span> )
  <span class="ruby-identifier">http</span>       = <span class="ruby-constant">Net</span><span class="ruby-operator">::</span><span class="ruby-constant">HTTP</span>.<span class="ruby-identifier">new</span>( <span class="ruby-identifier">remote_uri</span>.<span class="ruby-identifier">host</span>, <span class="ruby-identifier">remote_uri</span>.<span class="ruby-identifier">port</span> )

  <span class="ruby-identifier">request_class</span> = {
    <span class="ruby-string">&#39;POST&#39;</span>   =<span class="ruby-operator">&gt;</span> <span class="ruby-constant">Net</span><span class="ruby-operator">::</span><span class="ruby-constant">HTTP</span><span class="ruby-operator">::</span><span class="ruby-constant">Post</span>,
    <span class="ruby-string">&#39;PATCH&#39;</span>  =<span class="ruby-operator">&gt;</span> <span class="ruby-constant">Net</span><span class="ruby-operator">::</span><span class="ruby-constant">HTTP</span><span class="ruby-operator">::</span><span class="ruby-constant">Patch</span>,
    <span class="ruby-string">&#39;DELETE&#39;</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-constant">Net</span><span class="ruby-operator">::</span><span class="ruby-constant">HTTP</span><span class="ruby-operator">::</span><span class="ruby-constant">Delete</span>
  }[ <span class="ruby-identifier">http_method</span> ] <span class="ruby-operator">||</span> <span class="ruby-constant">Net</span><span class="ruby-operator">::</span><span class="ruby-constant">HTTP</span><span class="ruby-operator">::</span><span class="ruby-constant">Get</span>

  <span class="ruby-identifier">request</span>      = <span class="ruby-identifier">request_class</span>.<span class="ruby-identifier">new</span>( <span class="ruby-identifier">remote_uri</span>.<span class="ruby-identifier">request_uri</span>() )
  <span class="ruby-identifier">request</span>.<span class="ruby-identifier">body</span> = <span class="ruby-identifier">body_data</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">body_data</span>.<span class="ruby-identifier">empty?</span>

  <span class="ruby-identifier">request</span>.<span class="ruby-identifier">initialize_http_header</span>( <span class="ruby-identifier">headers</span> )

  <span class="ruby-keyword">begin</span>
    <span class="ruby-identifier">response</span> = <span class="ruby-identifier">http</span>.<span class="ruby-identifier">request</span>( <span class="ruby-identifier">request</span> )
  <span class="ruby-keyword">rescue</span> <span class="ruby-constant">Errno</span><span class="ruby-operator">::</span><span class="ruby-constant">ECONNREFUSED</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">e</span>
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">add_404</span>.<span class="ruby-identifier">call</span>()
  <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># Parse the response (assumed valid JSON else #for_rack would have failed</span>
  <span class="ruby-comment"># when the originating response object was turned into the Rack response).</span>

  <span class="ruby-identifier">parsed</span> = <span class="ruby-constant">JSON</span>.<span class="ruby-identifier">parse</span>( <span class="ruby-identifier">response</span>.<span class="ruby-identifier">body</span> )

  <span class="ruby-comment"># Deal with headers sent in the call.</span>

  <span class="ruby-identifier">ignores</span> = <span class="ruby-constant">Set</span>.<span class="ruby-identifier">new</span>( [

    <span class="ruby-comment"># These are standard and automatic anyway</span>

    <span class="ruby-string">&#39;content-type&#39;</span>,
    <span class="ruby-string">&#39;content-language&#39;</span>,
    <span class="ruby-string">&#39;x-interaction-id&#39;</span>,
    <span class="ruby-string">&#39;x-session-id&#39;</span>,

    <span class="ruby-comment"># These can be set by HTTP operations and we&#39;re not interested in them</span>

    <span class="ruby-string">&#39;content-length&#39;</span>,
    <span class="ruby-string">&#39;server&#39;</span>,
    <span class="ruby-string">&#39;date&#39;</span>,
    <span class="ruby-string">&#39;connection&#39;</span>

  ] )

  <span class="ruby-identifier">response</span>.<span class="ruby-identifier">each_header</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span> <span class="ruby-identifier">name</span>, <span class="ruby-identifier">value</span> <span class="ruby-operator">|</span>
    <span class="ruby-ivar">@service_response</span>.<span class="ruby-identifier">add_header</span>( <span class="ruby-identifier">name</span>, <span class="ruby-identifier">value</span>, <span class="ruby-keyword">true</span> ) <span class="ruby-keyword">unless</span> <span class="ruby-identifier">ignores</span>.<span class="ruby-identifier">include?</span>( <span class="ruby-identifier">name</span> )
  <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># Since &quot;parsed&quot; now has the decoded Hash payload, we use it to see if</span>
  <span class="ruby-comment"># there is error data there. If so, add it verbatim into the local errors</span>
  <span class="ruby-comment"># collection. Attempt to carry over the remote call&#39;s HTTP status code.</span>

  <span class="ruby-keyword">if</span> <span class="ruby-identifier">response</span>.<span class="ruby-identifier">code</span>.<span class="ruby-identifier">to_i</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">299</span>
    <span class="ruby-ivar">@service_response</span>.<span class="ruby-identifier">http_status_code</span> = <span class="ruby-identifier">response</span>.<span class="ruby-identifier">code</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-keyword">if</span> ( <span class="ruby-identifier">parsed</span>[ <span class="ruby-string">&#39;kind&#39;</span> ] <span class="ruby-operator">==</span> <span class="ruby-string">&#39;Errors&#39;</span> )
    <span class="ruby-identifier">parsed</span>[ <span class="ruby-string">&#39;errors&#39;</span> ].<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span> <span class="ruby-identifier">error</span> <span class="ruby-operator">|</span>
      <span class="ruby-ivar">@service_response</span>.<span class="ruby-identifier">add_precompiled_error</span>(
        <span class="ruby-identifier">error</span>[ <span class="ruby-string">&#39;code&#39;</span>      ],
        <span class="ruby-identifier">error</span>[ <span class="ruby-string">&#39;message&#39;</span>   ],
        <span class="ruby-identifier">error</span>[ <span class="ruby-string">&#39;reference&#39;</span> ],
        <span class="ruby-identifier">response</span>.<span class="ruby-identifier">code</span>
      )
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># If the parsed data wrapped an array, extract just the array part.</span>

  <span class="ruby-keyword">if</span> ( <span class="ruby-identifier">parsed</span>[ <span class="ruby-string">&#39;_data&#39;</span> ].<span class="ruby-identifier">is_a?</span>( <span class="ruby-operator">::</span><span class="ruby-constant">Array</span> ) )
    <span class="ruby-identifier">parsed</span> = <span class="ruby-identifier">parsed</span>[ <span class="ruby-string">&#39;_data&#39;</span> ]
  <span class="ruby-keyword">end</span>

  <span class="ruby-keyword">return</span> <span class="ruby-identifier">parsed</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-local_service_for" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">local_service_for</span><span
            class="method-args">( resource, version = 1 )</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Is the given resource available as a local endpoint in this service
application?</p>
<dl class="rdoc-list note-list"><dt><code>resource</code>
<dd>
<p>Resource name of interest, e.g. <code>:Purchase</code>. String or symbol.</p>
</dd><dt><code>version</code>
<dd>
<p>Version of interface required as an Integer. Optional - default is 1.</p>
</dd></dl>

<p>Returns an @services entry (see implementation of initialize) if local,
else <code>nil</code>.</p>
          
          

          
          <div class="method-source-code" id="local_service_for-source">
            <pre><span class="ruby-comment"># File lib/api_tools/service_middleware/service_middleware.rb, line 1056</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">local_service_for</span>( <span class="ruby-identifier">resource</span>, <span class="ruby-identifier">version</span> = <span class="ruby-value">1</span> )
  <span class="ruby-identifier">resource</span> = <span class="ruby-identifier">resource</span>.<span class="ruby-identifier">to_sym</span>
  <span class="ruby-identifier">version</span>  = <span class="ruby-identifier">version</span>.<span class="ruby-identifier">to_i</span>

  <span class="ruby-ivar">@services</span>.<span class="ruby-identifier">find</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span> <span class="ruby-identifier">entry</span> <span class="ruby-operator">|</span>
    <span class="ruby-identifier">interface</span> = <span class="ruby-identifier">entry</span>[ <span class="ruby-value">:interface</span> ]
    <span class="ruby-identifier">interface</span>.<span class="ruby-identifier">resource</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">resource</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">interface</span>.<span class="ruby-identifier">version</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">version</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-remote_service_for" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">remote_service_for</span><span
            class="method-args">( resource, version = 1 )</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Is the given resource available as a remote endpoint we can target via
HTTP?</p>
<dl class="rdoc-list note-list"><dt><code>resource</code>
<dd>
<p>Resource name of interest, e.g. <code>:Purchase</code>. String or symbol.</p>
</dd><dt><code>version</code>
<dd>
<p>Version of interface required as an Integer. Optional - default is 1.</p>
</dd></dl>

<p>Returns a URI as a string if an endpoint is found, else <code>nil</code>.</p>
          
          

          
          <div class="method-source-code" id="remote_service_for-source">
            <pre><span class="ruby-comment"># File lib/api_tools/service_middleware/service_middleware.rb, line 1077</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">remote_service_for</span>( <span class="ruby-identifier">resource</span>, <span class="ruby-identifier">version</span> = <span class="ruby-value">1</span> )
  <span class="ruby-keyword">begin</span>
    <span class="ruby-ivar">@drb_service</span>.<span class="ruby-identifier">find</span>( <span class="ruby-identifier">resource</span>, <span class="ruby-identifier">version</span> )
  <span class="ruby-keyword">rescue</span>
    <span class="ruby-keyword">nil</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
    </section>
  
  </section>
</main>


<footer id="validator-badges" role="contentinfo">
  <p><a href="http://validator.w3.org/check/referer">Validate</a>
  <p>Generated by <a href="http://rdoc.rubyforge.org">RDoc</a> 4.1.2.
  <p>Based on <a href="http://deveiate.org/projects/Darkfish-Rdoc/">Darkfish</a> by <a href="http://deveiate.org">Michael Granger</a>.
</footer>

