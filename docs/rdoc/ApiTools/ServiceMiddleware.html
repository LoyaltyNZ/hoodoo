<!DOCTYPE html>

<html>
<head>
<meta charset="UTF-8">

<title>class ApiTools::ServiceMiddleware - RDoc Documentation</title>

<link href="../fonts.css" rel="stylesheet">
<link href="../rdoc.css" rel="stylesheet">

<script type="text/javascript">
  var rdoc_rel_prefix = "../";
</script>

<script src="../js/jquery.js"></script>
<script src="../js/navigation.js"></script>
<script src="../js/search_index.js"></script>
<script src="../js/search.js"></script>
<script src="../js/searcher.js"></script>
<script src="../js/darkfish.js"></script>


<body id="top" role="document" class="class">
<nav role="navigation">
  <div id="project-navigation">
    <div id="home-section" role="region" title="Quick navigation" class="nav-section">
  <h2>
    <a href="../index.html" rel="home">Home</a>
  </h2>

  <div id="table-of-contents-navigation">
    <a href="../table_of_contents.html#pages">Pages</a>
    <a href="../table_of_contents.html#classes">Classes</a>
    <a href="../table_of_contents.html#methods">Methods</a>
  </div>
</div>

    <div id="search-section" role="search" class="project-section initially-hidden">
  <form action="#" method="get" accept-charset="utf-8">
    <div id="search-field-wrapper">
      <input id="search-field" role="combobox" aria-label="Search"
             aria-autocomplete="list" aria-controls="search-results"
             type="text" name="search" placeholder="Search" spellcheck="false"
             title="Type to search, Up and Down to navigate, Enter to load">
    </div>

    <ul id="search-results" aria-label="Search Results"
        aria-busy="false" aria-expanded="false"
        aria-atomic="false" class="initially-hidden"></ul>
  </form>
</div>

  </div>

  

  <div id="class-metadata">
    
    <div id="parent-class-section" class="nav-section">
  <h3>Parent</h3>

  
  <p class="link">Object
  
</div>

    
    
    <!-- Method Quickref -->
<div id="method-list-section" class="nav-section">
  <h3>Methods</h3>

  <ul class="link-list" role="directory">
    
    <li ><a href="#method-c-environment">::environment</a>
    
    <li ><a href="#method-c-new">::new</a>
    
    <li ><a href="#method-i-call">#call</a>
    
    <li ><a href="#method-i-development_port_for">#development_port_for</a>
    
    <li ><a href="#method-i-inter_service">#inter_service</a>
    
    <li ><a href="#method-i-inter_service_local">#inter_service_local</a>
    
    <li ><a href="#method-i-inter_service_remote">#inter_service_remote</a>
    
    <li ><a href="#method-i-local_service_for">#local_service_for</a>
    
  </ul>
</div>

  </div>
</nav>

<main role="main" aria-labelledby="class-ApiTools::ServiceMiddleware">
  <h1 id="class-ApiTools::ServiceMiddleware" class="class">
    class ApiTools::ServiceMiddleware
  </h1>

  <section class="description">
    
<p>Rack middleware, declared in (e.g.) a <code>config.ru</code> file in the
usual way:</p>

<pre>use( ApiTools::ServiceMiddleware )</pre>

<p>This is the core of the common service implementation on the Rack
client-request-handling side. It is run in the context of an <a
href="ServiceApplication.html">ApiTools::ServiceApplication</a> subclass
that&#39;s been given to Rack as the Rack endpoint application; it looks at
the component interfaces supported by the service and routes requests to
the correct one (or raises a 404).</p>

<p>Lots of preprocessing and postprocessing gets done to set up things like
locale information, enforce content types and so-forth. Request data is
assembled in a parsed, structured format for passing to service
implementations and a response object built so that services have a
consistent way to return results, which can be post-processed further by
the middleware before returning the data to Rack.</p>

  </section>

  
  
  
  <section id="5Buntitled-5D" class="documentation-section">
    

    

    
    <section class="constants-list">
      <header>
        <h3>Constants</h3>
      </header>
      <dl>
      
        <dt id="ALLOWED_ACTIONS">ALLOWED_ACTIONS
        
        <dd><p>All allowed action names in implementations, used for internal checks. This
is also the default supported set of actions. Symbols.</p>
        
      
        <dt id="ALLOWED_QUERIES_ALL">ALLOWED_QUERIES_ALL
        
        <dd><p>Allowed common fields in query strings (all actions). Strings. Adds to the
::ALLOWED_QUERIES_LIST for list actions.</p>

<p>Only ever <strong>add</strong> to this list. As the API evolves, legacy
clients will be calling with previously documented query strings and
removing any entries from the list below could cause their requests to be
rejected with a &#39;platform.malformed&#39; error.</p>
        
      
        <dt id="ALLOWED_QUERIES_LIST">ALLOWED_QUERIES_LIST
        
        <dd><p>Allowed common fields in query strings (list actions only). Strings.</p>

<p>Only ever <strong>add</strong> to this list. As the API evolves, legacy
clients will be calling with previously documented query strings and
removing any entries from the list below could cause their requests to be
rejected with a &#39;platform.malformed&#39; error.</p>
        
      
        <dt id="MAXIMUM_PAYLOAD_SIZE">MAXIMUM_PAYLOAD_SIZE
        
        <dd><p>Somewhat arbitrary maximum incoming payload size to prevent ham-fisted DOS
attempts to consume RAM.</p>
        
      
        <dt id="SUPPORTED_ENCODINGS">SUPPORTED_ENCODINGS
        
        <dd><p>Allowed (required) charsets in Content-Type headers.</p>
        
      
        <dt id="SUPPORTED_MEDIA_TYPES">SUPPORTED_MEDIA_TYPES
        
        <dd><p>Allowed media types in Content-Type headers.</p>
        
      
      </dl>
    </section>
    

    

    
     <section id="public-class-5Buntitled-5D-method-details" class="method-section">
       <header>
         <h3>Public Class Methods</h3>
       </header>

    
      <div id="method-c-environment" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">environment</span><span
            class="method-args">()</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Utility - returns the execution environment as a Rails-like environment
object which answers queries like <code>production?</code> or
<code>staging?</code> with <code>true</code> or <code>false</code>
according to the <code>RACK_ENV</code> environment variable setting.</p>

<p>Example:</p>

<pre>if ApiTools::ServiceMiddleware.environment.production?
  # ...do something only if RACK_ENV=&quot;production&quot;
end</pre>
          
          

          
          <div class="method-source-code" id="environment-source">
            <pre><span class="ruby-comment"># File lib/api_tools/service_middleware/service_middleware.rb, line 98</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">environment</span>
  <span class="ruby-ivar">@_env</span> <span class="ruby-operator">||=</span> <span class="ruby-constant">ApiTools</span><span class="ruby-operator">::</span><span class="ruby-constant">StringInquirer</span>.<span class="ruby-identifier">new</span>( <span class="ruby-constant">ENV</span>[ <span class="ruby-string">&#39;RACK_ENV&#39;</span> ] <span class="ruby-operator">||</span> <span class="ruby-string">&#39;development&#39;</span> )
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-c-new" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">new</span><span
            class="method-args">( app )</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Initialize the middleware instance.</p>

<p><code>app</code> Rack app instance to which calls should be passed.</p>
          
          

          
          <div class="method-source-code" id="new-source">
            <pre><span class="ruby-comment"># File lib/api_tools/service_middleware/service_middleware.rb, line 106</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">initialize</span>( <span class="ruby-identifier">app</span> )
  <span class="ruby-ivar">@service_container</span> = <span class="ruby-identifier">app</span>
  <span class="ruby-ivar">@interaction_id</span>    = <span class="ruby-keyword">nil</span> <span class="ruby-comment"># Acquired in #find_or_generate_interaction_id</span>

  <span class="ruby-keyword">unless</span> <span class="ruby-ivar">@service_container</span>.<span class="ruby-identifier">is_a?</span>( <span class="ruby-constant">ApiTools</span><span class="ruby-operator">::</span><span class="ruby-constant">ServiceApplication</span> )
    <span class="ruby-identifier">raise</span> <span class="ruby-node">&quot;ApiTools::ServiceMiddleware instance created with non-ServiceApplication entity of class &#39;#{ app.class }&#39; - is this the last middleware in the chain via &#39;use()&#39; and is Rack &#39;run()&#39;-ing the correct thing?&quot;</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># Collect together the implementation instances and the matching regexps</span>
  <span class="ruby-comment"># for endpoints. An array of hashes.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># Key              Value</span>
  <span class="ruby-comment"># =======================================================================</span>
  <span class="ruby-comment"># regexp           Regexp for +String#match+ on the URI path component</span>
  <span class="ruby-comment"># interface        ApiTools::ServiceInterface subclass associated with</span>
  <span class="ruby-comment">#                  the endpoint regular expression in +regexp+</span>
  <span class="ruby-comment"># actions          Array of symbols naming allowed actions</span>
  <span class="ruby-comment"># implementation   ApiTools::ServiceImplementation subclass *instance* to</span>
  <span class="ruby-comment">#                  use on match</span>

  <span class="ruby-ivar">@services</span> = <span class="ruby-ivar">@service_container</span>.<span class="ruby-identifier">component_interfaces</span>.<span class="ruby-identifier">map</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span> <span class="ruby-identifier">interface</span> <span class="ruby-operator">|</span>

    <span class="ruby-keyword">if</span> <span class="ruby-identifier">interface</span>.<span class="ruby-identifier">nil?</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">interface</span>.<span class="ruby-identifier">endpoint</span>.<span class="ruby-identifier">nil?</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">interface</span>.<span class="ruby-identifier">implementation</span>.<span class="ruby-identifier">nil?</span>
      <span class="ruby-identifier">raise</span> <span class="ruby-node">&quot;ApiTools::ServiceMiddleware encountered invalid interface class #{ interface } via service class #{ app.class }&quot;</span>
    <span class="ruby-keyword">end</span>

    <span class="ruby-comment"># Regexp explanation:</span>
    <span class="ruby-comment">#</span>
    <span class="ruby-comment"># Match &quot;/&quot;, the version text, &quot;/&quot;, the endpoint text, then either</span>
    <span class="ruby-comment"># another &quot;/&quot;, a &quot;.&quot; or the end of the string, followed by capturing</span>
    <span class="ruby-comment"># everything else. Match data index 1 will be whatever character (if</span>
    <span class="ruby-comment"># any) followed after the endpoint (&quot;/&quot; or &quot;.&quot;) while index 2 contains</span>
    <span class="ruby-comment"># everything else.</span>

    {
      <span class="ruby-value">:regexp</span>         =<span class="ruby-operator">&gt;</span> <span class="ruby-node">/\/v#{ interface.version }\/#{ interface.endpoint }(\.|\/|$)(.*)/</span>,
      <span class="ruby-value">:interface</span>      =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">interface</span>,
      <span class="ruby-value">:implementation</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">interface</span>.<span class="ruby-identifier">implementation</span>.<span class="ruby-identifier">new</span>
    }

  <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># TODO: By now the resource, version and endpoint information is all</span>
  <span class="ruby-comment">#       known. This is where we&#39;d tell a router, edge splitter or some</span>
  <span class="ruby-comment">#       other component about this instance as part of a wider</span>
  <span class="ruby-comment">#       configuration set that allowed inter-service communication.</span>

  <span class="ruby-comment"># TODO: If we can find out what port this thing is being served on (or</span>
  <span class="ruby-comment">#       determine we&#39;re under Alchemy), then we can dynamically note</span>
  <span class="ruby-comment">#       the endpoint and not have to hard-code development ports.</span>

<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
    </section>
  
     <section id="public-instance-5Buntitled-5D-method-details" class="method-section">
       <header>
         <h3>Public Instance Methods</h3>
       </header>

    
      <div id="method-i-call" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">call</span><span
            class="method-args">( env )</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Run a Rack request, returning the [status, headers, body-array] data as per
the Rack protocol requirements.</p>

<p><code>env</code> Rack environment.</p>
          
          

          
          <div class="method-source-code" id="call-source">
            <pre><span class="ruby-comment"># File lib/api_tools/service_middleware/service_middleware.rb, line 164</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">call</span>( <span class="ruby-identifier">env</span> )

  <span class="ruby-comment"># Global exception handler - catch problems in service implementations</span>
  <span class="ruby-comment"># and send back a 500 response as per API documentation (if possible).</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-keyword">begin</span>

    <span class="ruby-constant">ApiTools</span><span class="ruby-operator">::</span><span class="ruby-constant">Logger</span>.<span class="ruby-identifier">send</span>(
      <span class="ruby-value">:debug</span>,
      <span class="ruby-string">&#39;ApiTools::ServiceMiddleware#call with Rack &quot;env&quot;:&#39;</span>,
      <span class="ruby-identifier">env</span>.<span class="ruby-identifier">inspect</span>
    )

    <span class="ruby-ivar">@rack_request</span> = <span class="ruby-constant">Rack</span><span class="ruby-operator">::</span><span class="ruby-constant">Request</span>.<span class="ruby-identifier">new</span>( <span class="ruby-identifier">env</span> )

    <span class="ruby-identifier">log</span>( <span class="ruby-value">:info</span> )

    <span class="ruby-ivar">@service_response</span> = <span class="ruby-constant">ApiTools</span><span class="ruby-operator">::</span><span class="ruby-constant">ServiceResponse</span>.<span class="ruby-identifier">new</span>
    <span class="ruby-ivar">@service_session</span>  = <span class="ruby-constant">ApiTools</span><span class="ruby-operator">::</span><span class="ruby-constant">ServiceSession</span>.<span class="ruby-identifier">new</span>

    <span class="ruby-comment"># TODO: Session validation/recovery, probably in preprocess()</span>

    <span class="ruby-identifier">preprocess</span>()
    <span class="ruby-identifier">process</span>()     <span class="ruby-keyword">unless</span> <span class="ruby-ivar">@service_response</span>.<span class="ruby-identifier">halt_processing?</span>
    <span class="ruby-identifier">postprocess</span>() <span class="ruby-keyword">unless</span> <span class="ruby-ivar">@service_response</span>.<span class="ruby-identifier">halt_processing?</span>

    <span class="ruby-keyword">return</span> <span class="ruby-identifier">respond_with</span>( <span class="ruby-ivar">@service_response</span>.<span class="ruby-identifier">for_rack</span>() )

  <span class="ruby-keyword">rescue</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">exception</span>
    <span class="ruby-keyword">begin</span>
      <span class="ruby-keyword">return</span> <span class="ruby-identifier">respond_with</span>( <span class="ruby-identifier">record_exception</span>( <span class="ruby-ivar">@service_response</span>, <span class="ruby-identifier">exception</span> ) )

    <span class="ruby-keyword">rescue</span>

      <span class="ruby-keyword">begin</span>
        <span class="ruby-constant">ApiTools</span><span class="ruby-operator">::</span><span class="ruby-constant">Logger</span>.<span class="ruby-identifier">error</span>(
          <span class="ruby-string">&#39;ApiTools::ServiceMiddleware#call&#39;</span>,
          <span class="ruby-string">&#39;Middleware exception in exception handler&#39;</span>,
          <span class="ruby-identifier">exception</span>.<span class="ruby-identifier">to_s</span>
        )
      <span class="ruby-keyword">rescue</span>
        <span class="ruby-comment"># Ignore logger exceptions. Can&#39;t do anything about them. Just</span>
        <span class="ruby-comment"># try and get the response back to the client now.</span>
      <span class="ruby-keyword">end</span>

      <span class="ruby-comment"># An exception in the exception handler! Oh dear.</span>
      <span class="ruby-comment">#</span>
      <span class="ruby-keyword">return</span> [
        <span class="ruby-value">500</span>, {}, <span class="ruby-constant">Rack</span><span class="ruby-operator">::</span><span class="ruby-constant">BodyProxy</span>.<span class="ruby-identifier">new</span>( [ <span class="ruby-string">&#39;Middleware exception in exception handler&#39;</span> ] ) {}
      ]

    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
    </section>
  
     <section id="protected-instance-5Buntitled-5D-method-details" class="method-section">
       <header>
         <h3>Protected Instance Methods</h3>
       </header>

    
      <div id="method-i-development_port_for" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">development_port_for</span><span
            class="method-args">( resource )</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>PROVISIONAL!</p>

<p>Local development no-queue port allocations on an assumed physical service
grouping.</p>
<dl class="rdoc-list note-list"><dt><code>resource</code>
<dd>
<p>Resource name of interest, e.g. <code>:Purchase</code>. String or symbol.</p>
</dd></dl>
          
          

          
          <div class="method-source-code" id="development_port_for-source">
            <pre><span class="ruby-comment"># File lib/api_tools/service_middleware/service_middleware.rb, line 940</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">development_port_for</span>( <span class="ruby-identifier">resource</span> )
  <span class="ruby-keyword">case</span> <span class="ruby-identifier">resource</span>.<span class="ruby-identifier">to_sym</span>

    <span class="ruby-comment"># Errors Service</span>
    <span class="ruby-keyword">when</span> <span class="ruby-value">:Errors</span>
      <span class="ruby-value">3500</span>

    <span class="ruby-comment"># Financial Service</span>
    <span class="ruby-keyword">when</span> <span class="ruby-value">:Currency</span>, <span class="ruby-value">:Balance</span>, <span class="ruby-value">:Voucher</span>, <span class="ruby-value">:Transaction</span>
      <span class="ruby-value">3510</span>

    <span class="ruby-comment"># Programme API</span>
    <span class="ruby-keyword">when</span> <span class="ruby-value">:Participant</span>, <span class="ruby-value">:Outlet</span>, <span class="ruby-value">:Involvement</span>, <span class="ruby-value">:Programme</span>
      <span class="ruby-value">3520</span>

    <span class="ruby-comment"># Member API</span>
    <span class="ruby-keyword">when</span> <span class="ruby-value">:Account</span>, <span class="ruby-value">:Member</span>, <span class="ruby-value">:Membership</span>, <span class="ruby-value">:MemberToken</span>
      <span class="ruby-value">3530</span>

    <span class="ruby-comment"># Purchase API</span>
    <span class="ruby-keyword">when</span> <span class="ruby-value">:Purchase</span>, <span class="ruby-value">:Refund</span>, <span class="ruby-value">:Estimation</span>, <span class="ruby-value">:Forecast</span>, <span class="ruby-value">:Calculator</span>
      <span class="ruby-value">3540</span>

    <span class="ruby-comment"># Utility API</span>
    <span class="ruby-keyword">when</span> <span class="ruby-value">:Version</span>
      <span class="ruby-value">3550</span>

    <span class="ruby-keyword">else</span>
      <span class="ruby-value">9393</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-inter_service" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">inter_service</span><span
            class="method-args">( options )</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Perform an inter-service call. This shouldn&#39;t be called directly; call
via the <a
href="ServiceMiddleware/ServiceEndpoint.html">ApiTools::ServiceMiddleware::ServiceEndpoint</a>
subclass specialised methods instead, which makes sure it sets up the
required parameters in correct combinations. Undefined results will arise
for incorrect calls.</p>
<dl class="rdoc-list note-list"><dt><code>options</code>
<dd>
<p>Options hash with keys and required values described below.</p>
</dd></dl>

<p>Options are as follows - keys must be Symbols:</p>
<dl class="rdoc-list note-list"><dt><code>service</code>
<dd>
<p>A +@services+ entry (see implementation of initialize) describing the
service to call if local, else <code>nil</code> or absent.</p>
</dd><dt><code>http_method</code>
<dd>
<p>HTTP method as a String, e.g. +&#39;GET&#39;+, +&#39;DELETE&#39;+.</p>
</dd><dt><code>ident</code>
<dd>
<p>ID / <a href="UUID.html">UUID</a> / similar; first and only path component.</p>
</dd><dt><code>query_hash</code>
<dd>
<p>Converted to query string.</p>
</dd><dt><code>body_hash</code>
<dd>
<p>Converted to body data.</p>
</dd></dl>

<p>Parameters should be nil where the value would not be allowed given the
HTTP method. HTTP methods must map to understood actions.</p>

<p>+@service_response+ is updated on exit. If this says “halt processing”,
errors were generated. Ignore the function return value. Otherwise, returns
a JSON resource representation in the non-list-action cases, else an array
of zero or more JSON resource representations in the list action case.</p>
          
          

          
          <div class="method-source-code" id="inter_service-source">
            <pre><span class="ruby-comment"># File lib/api_tools/service_middleware/service_middleware.rb, line 998</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">inter_service</span>( <span class="ruby-identifier">options</span> )

  <span class="ruby-identifier">remote</span> = <span class="ruby-identifier">options</span>[ <span class="ruby-value">:service</span> ].<span class="ruby-identifier">nil?</span>

  <span class="ruby-identifier">log</span>(
    <span class="ruby-value">:debug</span>,
    <span class="ruby-node">&quot;#{ remote ? &#39;Remote&#39; : &#39;Local&#39; } inter-service call requested with options #{ options }&quot;</span>
  )

  <span class="ruby-keyword">if</span> ( <span class="ruby-identifier">remote</span> )
    <span class="ruby-identifier">result</span> = <span class="ruby-identifier">inter_service_remote</span>( <span class="ruby-identifier">options</span> )
  <span class="ruby-keyword">else</span>
    <span class="ruby-identifier">result</span> = <span class="ruby-identifier">inter_service_local</span>( <span class="ruby-identifier">options</span> )
  <span class="ruby-keyword">end</span>

  <span class="ruby-keyword">if</span> <span class="ruby-ivar">@service_response</span>.<span class="ruby-identifier">halt_processing?</span>
    <span class="ruby-identifier">log</span>(
      <span class="ruby-value">:warn</span>,
      <span class="ruby-node">&quot;#{ remote ? &#39;Remote&#39; : &#39;Local&#39; } inter-service call halted processing with errors #{ @service_response.errors.errors }&quot;</span>
    )
  <span class="ruby-keyword">else</span>
    <span class="ruby-identifier">log</span>(
      <span class="ruby-value">:debug</span>,
      <span class="ruby-node">&quot;#{ remote ? &#39;Remote&#39; : &#39;Local&#39; } inter-service call succeeded with result &#39;#{ result }&#39;&quot;</span>
    )
  <span class="ruby-keyword">end</span>

  <span class="ruby-keyword">return</span> <span class="ruby-identifier">result</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-inter_service_local" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">inter_service_local</span><span
            class="method-args">( options )</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Make a local (non-HTTP local Ruby method call) inter-service call. Fast.</p>
<dl class="rdoc-list note-list"><dt><code>options</code>
<dd>
<p>See <a
href="ServiceMiddleware.html#method-i-inter_service">inter_service</a>.</p>
</dd><dt>Returns
<dd>
<p>See <a
href="ServiceMiddleware.html#method-i-inter_service">inter_service</a>.</p>
</dd></dl>
          
          

          
          <div class="method-source-code" id="inter_service_local-source">
            <pre><span class="ruby-comment"># File lib/api_tools/service_middleware/service_middleware.rb, line 1109</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">inter_service_local</span>( <span class="ruby-identifier">options</span> )
  <span class="ruby-identifier">service</span>        = <span class="ruby-identifier">options</span>[ <span class="ruby-value">:service</span>     ]
  <span class="ruby-identifier">http_method</span>    = <span class="ruby-identifier">options</span>[ <span class="ruby-value">:http_method</span> ]
  <span class="ruby-identifier">ident</span>          = <span class="ruby-identifier">options</span>[ <span class="ruby-value">:ident</span>       ]
  <span class="ruby-identifier">body_hash</span>      = <span class="ruby-identifier">options</span>[ <span class="ruby-value">:body_hash</span>   ]
  <span class="ruby-identifier">query_hash</span>     = <span class="ruby-identifier">options</span>[ <span class="ruby-value">:query_hash</span>  ]

  <span class="ruby-identifier">interface</span>      = <span class="ruby-identifier">service</span>[ <span class="ruby-value">:interface</span>      ]
  <span class="ruby-identifier">actions</span>        = <span class="ruby-identifier">service</span>[ <span class="ruby-value">:actions</span>        ]
  <span class="ruby-identifier">implementation</span> = <span class="ruby-identifier">service</span>[ <span class="ruby-value">:implementation</span> ]

  <span class="ruby-comment"># We must construct a call context for the local service. This means</span>
  <span class="ruby-comment"># a local request object which we fill in with data just as if we&#39;d</span>
  <span class="ruby-comment"># parsed an inbound HTTP request and a response object that contains</span>
  <span class="ruby-comment"># the usual default data.</span>

  <span class="ruby-identifier">local_service_response</span> = <span class="ruby-constant">ApiTools</span><span class="ruby-operator">::</span><span class="ruby-constant">ServiceResponse</span>.<span class="ruby-identifier">new</span>
  <span class="ruby-identifier">set_common_response_headers</span>( <span class="ruby-identifier">local_service_response</span> )
  <span class="ruby-identifier">update_service_response_for</span>( <span class="ruby-identifier">local_service_response</span>, <span class="ruby-identifier">interface</span> )

  <span class="ruby-identifier">upc</span>  = []
  <span class="ruby-identifier">upc</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">ident</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">ident</span>.<span class="ruby-identifier">nil?</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">ident</span>.<span class="ruby-identifier">empty?</span>

  <span class="ruby-identifier">action</span> = <span class="ruby-identifier">determine_action</span>(
    <span class="ruby-identifier">interface</span>,
    <span class="ruby-identifier">http_method</span>,
    <span class="ruby-identifier">upc</span>.<span class="ruby-identifier">empty?</span>,
    <span class="ruby-identifier">local_service_response</span>
  )

  <span class="ruby-keyword">if</span> <span class="ruby-identifier">local_service_response</span>.<span class="ruby-identifier">halt_processing?</span>
    <span class="ruby-ivar">@service_response</span>.<span class="ruby-identifier">errors</span>.<span class="ruby-identifier">merge!</span>( <span class="ruby-identifier">local_service_response</span>.<span class="ruby-identifier">errors</span> )
    <span class="ruby-keyword">return</span> <span class="ruby-keyword">nil</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">local_service_request</span>                     = <span class="ruby-identifier">new_service_request_for</span>( <span class="ruby-identifier">interface</span> )
  <span class="ruby-identifier">local_service_request</span>.<span class="ruby-identifier">uri_path_components</span> = <span class="ruby-identifier">upc</span>
  <span class="ruby-identifier">local_service_request</span>.<span class="ruby-identifier">uri_path_extension</span>  = <span class="ruby-string">&#39;&#39;</span>

  <span class="ruby-keyword">unless</span> <span class="ruby-identifier">query_hash</span>.<span class="ruby-identifier">nil?</span>
    <span class="ruby-identifier">query_hash</span> = <span class="ruby-constant">ApiTools</span><span class="ruby-operator">::</span><span class="ruby-constant">Utilities</span>.<span class="ruby-identifier">stringify</span>( <span class="ruby-identifier">query_hash</span> )

    <span class="ruby-comment"># This is for inter-service local calls where a service author</span>
    <span class="ruby-comment"># specifies &quot;:_embed =&gt; &#39;foo&#39;&quot; accidentally, forgetting that it</span>
    <span class="ruby-comment"># should be a single element array. It&#39;s such a common mistake</span>
    <span class="ruby-comment"># that we tolerate it here. Same for &quot;_reference&quot;.</span>

    <span class="ruby-identifier">data</span> = <span class="ruby-identifier">query_hash</span>[ <span class="ruby-string">&#39;_embed&#39;</span> ]
    <span class="ruby-identifier">query_hash</span>[ <span class="ruby-string">&#39;_embed&#39;</span> ] = [ <span class="ruby-identifier">data</span> ] <span class="ruby-keyword">if</span> <span class="ruby-identifier">data</span>.<span class="ruby-identifier">is_a?</span>( <span class="ruby-constant">String</span> ) <span class="ruby-operator">||</span> <span class="ruby-identifier">data</span>.<span class="ruby-identifier">is_a?</span>( <span class="ruby-constant">Symbol</span> )

    <span class="ruby-identifier">data</span> = <span class="ruby-identifier">query_hash</span>[ <span class="ruby-string">&#39;_reference&#39;</span> ]
    <span class="ruby-identifier">query_hash</span>[ <span class="ruby-string">&#39;_reference&#39;</span> ] = [ <span class="ruby-identifier">data</span> ] <span class="ruby-keyword">if</span> <span class="ruby-identifier">data</span>.<span class="ruby-identifier">is_a?</span>( <span class="ruby-constant">String</span> ) <span class="ruby-operator">||</span> <span class="ruby-identifier">data</span>.<span class="ruby-identifier">is_a?</span>( <span class="ruby-constant">Symbol</span> )

    <span class="ruby-comment"># Regardless, make sure embed/reference array data contains strings.</span>

    <span class="ruby-identifier">query_hash</span>[ <span class="ruby-string">&#39;_embed&#39;</span>     ].<span class="ruby-identifier">map!</span>( <span class="ruby-operator">&amp;</span><span class="ruby-value">:to_s</span> ) <span class="ruby-keyword">unless</span> <span class="ruby-identifier">query_hash</span>[ <span class="ruby-string">&#39;_embed&#39;</span>     ].<span class="ruby-identifier">nil?</span>
    <span class="ruby-identifier">query_hash</span>[ <span class="ruby-string">&#39;_reference&#39;</span> ].<span class="ruby-identifier">map!</span>( <span class="ruby-operator">&amp;</span><span class="ruby-value">:to_s</span> ) <span class="ruby-keyword">unless</span> <span class="ruby-identifier">query_hash</span>[ <span class="ruby-string">&#39;_reference&#39;</span> ].<span class="ruby-identifier">nil?</span>

    <span class="ruby-identifier">process_query_hash</span>(
      <span class="ruby-identifier">action</span>,
      <span class="ruby-identifier">query_hash</span>,
      <span class="ruby-identifier">interface</span>,
      <span class="ruby-identifier">local_service_request</span>,
      <span class="ruby-identifier">local_service_response</span>
    )
  <span class="ruby-keyword">end</span>

  <span class="ruby-keyword">if</span> <span class="ruby-identifier">local_service_response</span>.<span class="ruby-identifier">halt_processing?</span>
    <span class="ruby-ivar">@service_response</span>.<span class="ruby-identifier">errors</span>.<span class="ruby-identifier">merge!</span>( <span class="ruby-identifier">local_service_response</span>.<span class="ruby-identifier">errors</span> )
    <span class="ruby-keyword">return</span> <span class="ruby-keyword">nil</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">local_service_request</span>.<span class="ruby-identifier">body</span> = <span class="ruby-identifier">body_hash</span>

  <span class="ruby-comment"># Dispatch the call, merge any errors that might have come back and</span>
  <span class="ruby-comment"># return the body of the called service&#39;s response.</span>

  <span class="ruby-identifier">log</span>(
    <span class="ruby-value">:debug</span>,
    <span class="ruby-node">&quot;Dispatching local inter-service call with parsed body data: &#39;#{ local_service_request.body }&#39;&quot;</span>
  )

  <span class="ruby-identifier">context</span> = <span class="ruby-constant">ApiTools</span><span class="ruby-operator">::</span><span class="ruby-constant">ServiceContext</span>.<span class="ruby-identifier">new</span>(
    <span class="ruby-ivar">@service_session</span>,
    <span class="ruby-identifier">local_service_request</span>,
    <span class="ruby-identifier">local_service_response</span>,
    <span class="ruby-keyword">self</span>
  )

  <span class="ruby-identifier">implementation</span>.<span class="ruby-identifier">send</span>( <span class="ruby-identifier">action</span>, <span class="ruby-identifier">context</span> )
  <span class="ruby-ivar">@service_response</span>.<span class="ruby-identifier">errors</span>.<span class="ruby-identifier">merge!</span>( <span class="ruby-identifier">local_service_response</span>.<span class="ruby-identifier">errors</span> )
  <span class="ruby-keyword">return</span> <span class="ruby-identifier">local_service_response</span>.<span class="ruby-identifier">body</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-inter_service_remote" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">inter_service_remote</span><span
            class="method-args">( options )</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Make a remote (HTTP) inter-service call. Slow.</p>
<dl class="rdoc-list note-list"><dt><code>options</code>
<dd>
<p>See <a
href="ServiceMiddleware.html#method-i-inter_service">inter_service</a>.</p>
</dd><dt>Returns
<dd>
<p>See <a
href="ServiceMiddleware.html#method-i-inter_service">inter_service</a>.</p>
</dd></dl>
          
          

          
          <div class="method-source-code" id="inter_service_remote-source">
            <pre><span class="ruby-comment"># File lib/api_tools/service_middleware/service_middleware.rb, line 1034</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">inter_service_remote</span>( <span class="ruby-identifier">options</span> )
  <span class="ruby-identifier">service</span>     = <span class="ruby-identifier">options</span>[ <span class="ruby-value">:service</span>     ] <span class="ruby-comment"># !!! TBD will be nil; need resource here</span>
  <span class="ruby-identifier">http_method</span> = <span class="ruby-identifier">options</span>[ <span class="ruby-value">:http_method</span> ]
  <span class="ruby-identifier">ident</span>       = <span class="ruby-identifier">options</span>[ <span class="ruby-value">:ident</span>       ]
  <span class="ruby-identifier">body_hash</span>   = <span class="ruby-identifier">options</span>[ <span class="ruby-value">:body_hash</span>   ]
  <span class="ruby-identifier">query_hash</span>  = <span class="ruby-identifier">options</span>[ <span class="ruby-value">:query_hash</span>  ]

  <span class="ruby-identifier">host</span> = <span class="ruby-identifier">port</span> = <span class="ruby-keyword">nil</span>

  <span class="ruby-keyword">unless</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">class</span>.<span class="ruby-identifier">environment</span>.<span class="ruby-identifier">development?</span> <span class="ruby-operator">||</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">class</span>.<span class="ruby-identifier">environment</span>.<span class="ruby-identifier">test?</span>
    <span class="ruby-identifier">host</span> = <span class="ruby-ivar">@rack_request</span>.<span class="ruby-identifier">host</span>
    <span class="ruby-identifier">post</span> = <span class="ruby-ivar">@rack_request</span>.<span class="ruby-identifier">port</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">host</span> <span class="ruby-operator">||=</span> <span class="ruby-string">&#39;127.0.0.1&#39;</span>
  <span class="ruby-identifier">port</span> <span class="ruby-operator">||=</span> <span class="ruby-identifier">development_port_for</span>( <span class="ruby-identifier">interface</span>.<span class="ruby-identifier">resource</span> )
  <span class="ruby-identifier">path</span>   = <span class="ruby-node">&quot;/v#{ interface.version }/#{ interface.endpoint }&quot;</span>
  <span class="ruby-identifier">path</span>  <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-node">&quot;/#{ ident }&quot;</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">ident</span>.<span class="ruby-identifier">nil?</span>

  <span class="ruby-keyword">unless</span> <span class="ruby-identifier">query_hash</span>.<span class="ruby-identifier">nil?</span>
    <span class="ruby-identifier">query_hash</span> = <span class="ruby-identifier">query_hash</span>.<span class="ruby-identifier">dup</span>
    <span class="ruby-identifier">query_hash</span>[ <span class="ruby-value">:search</span> ] = <span class="ruby-constant">URI</span>.<span class="ruby-identifier">encode_www_form</span>( <span class="ruby-identifier">query_hash</span>[ <span class="ruby-value">:search</span> ] ) <span class="ruby-keyword">if</span> ( <span class="ruby-identifier">query_hash</span>[ <span class="ruby-value">:search</span> ] ).<span class="ruby-identifier">is_a?</span>( <span class="ruby-constant">Hash</span> )
    <span class="ruby-identifier">query_hash</span>[ <span class="ruby-value">:filter</span> ] = <span class="ruby-constant">URI</span>.<span class="ruby-identifier">encode_www_form</span>( <span class="ruby-identifier">query_hash</span>[ <span class="ruby-value">:filter</span> ] ) <span class="ruby-keyword">if</span> ( <span class="ruby-identifier">query_hash</span>[ <span class="ruby-value">:filter</span> ] ).<span class="ruby-identifier">is_a?</span>( <span class="ruby-constant">Hash</span> )
  <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># Grey area over whether this encodes spaces as &quot;%20&quot; or &quot;+&quot;, but so</span>
  <span class="ruby-comment"># long as the middleware consistently uses the URI encode/decode calls,</span>
  <span class="ruby-comment"># it should work out in the end anyway.</span>

  <span class="ruby-identifier">our_response</span> = <span class="ruby-constant">ApiTools</span><span class="ruby-operator">::</span><span class="ruby-constant">ServiceResponse</span>.<span class="ruby-identifier">new</span>

  <span class="ruby-keyword">begin</span>
    <span class="ruby-identifier">uri</span> = <span class="ruby-constant">URI</span><span class="ruby-operator">::</span><span class="ruby-constant">HTTP</span>.<span class="ruby-identifier">build</span>( {
      <span class="ruby-value">:host</span>  =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">host</span>,
      <span class="ruby-value">:port</span>  =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">port</span>.<span class="ruby-identifier">to_i</span>,
      <span class="ruby-value">:path</span>  =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">path</span>,
      <span class="ruby-value">:query</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-constant">URI</span>.<span class="ruby-identifier">encode_www_form</span>( <span class="ruby-identifier">query_hash</span> )
    } )

    <span class="ruby-identifier">remote_response</span> = <span class="ruby-constant">RestClient</span>.<span class="ruby-identifier">send</span>(
      <span class="ruby-identifier">http_method</span>,
      <span class="ruby-identifier">uri</span>.<span class="ruby-identifier">to_s</span>,
      <span class="ruby-identifier">body_hash</span>.<span class="ruby-identifier">nil?</span> <span class="ruby-operator">?</span> <span class="ruby-string">&#39;&#39;</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">body_hash</span>.<span class="ruby-identifier">to_json</span>
    )

    <span class="ruby-identifier">our_response</span>.<span class="ruby-identifier">http_status_code</span> = <span class="ruby-identifier">remote_response</span>.<span class="ruby-identifier">code</span>
    <span class="ruby-identifier">our_response</span>.<span class="ruby-identifier">body</span>             = <span class="ruby-constant">JSON</span>.<span class="ruby-identifier">parse</span>( <span class="ruby-identifier">remote_response</span>.<span class="ruby-identifier">to_str</span> )

    <span class="ruby-identifier">remote_response</span>.<span class="ruby-identifier">headers</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span> <span class="ruby-identifier">name</span>, <span class="ruby-identifier">value</span> <span class="ruby-operator">|</span>
      <span class="ruby-identifier">our_response</span>.<span class="ruby-identifier">add_header</span>( <span class="ruby-identifier">name</span>, <span class="ruby-identifier">value</span>, <span class="ruby-keyword">true</span> )
    <span class="ruby-keyword">end</span>

    <span class="ruby-comment"># Since &quot;our response&quot; now has the decoded Hash payload, we use it</span>
    <span class="ruby-comment"># to see if there is error data there. If so, add it verbatim into</span>
    <span class="ruby-comment"># the errors collection.</span>
    <span class="ruby-comment">#</span>
    <span class="ruby-keyword">if</span> ( <span class="ruby-identifier">our_response</span>.<span class="ruby-identifier">body</span>[ <span class="ruby-string">&#39;kind&#39;</span> ] <span class="ruby-operator">==</span> <span class="ruby-string">&#39;Errors&#39;</span> )
      <span class="ruby-identifier">our_response</span>.<span class="ruby-identifier">body</span>[ <span class="ruby-string">&#39;errors&#39;</span> ].<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span> <span class="ruby-identifier">error</span> <span class="ruby-operator">|</span>
        <span class="ruby-identifier">our_response</span>.<span class="ruby-identifier">add_precompiled_error</span>( <span class="ruby-identifier">error</span> )
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">end</span>

  <span class="ruby-keyword">rescue</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">exception</span>
    <span class="ruby-identifier">record_exception</span>( <span class="ruby-identifier">our_response</span>, <span class="ruby-identifier">exception</span> )
  <span class="ruby-keyword">end</span>

  <span class="ruby-keyword">return</span> <span class="ruby-identifier">our_response</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-local_service_for" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">local_service_for</span><span
            class="method-args">( resource )</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Is the given resource available as a local endpoint in this service
application?</p>
<dl class="rdoc-list note-list"><dt><code>resource</code>
<dd>
<p>Resource name of interest, e.g. <code>:Purchase</code>. String or symbol.</p>
</dd></dl>

<p>Returns a @services entry (see implementation of initialize) if local, else
<code>nil</code>.</p>
          
          

          
          <div class="method-source-code" id="local_service_for-source">
            <pre><span class="ruby-comment"># File lib/api_tools/service_middleware/service_middleware.rb, line 924</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">local_service_for</span>( <span class="ruby-identifier">resource</span> )
  <span class="ruby-identifier">resource</span> = <span class="ruby-identifier">resource</span>.<span class="ruby-identifier">to_sym</span>

  <span class="ruby-ivar">@services</span>.<span class="ruby-identifier">find</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span> <span class="ruby-identifier">entry</span> <span class="ruby-operator">|</span>
    <span class="ruby-identifier">entry</span>[ <span class="ruby-value">:interface</span> ].<span class="ruby-identifier">resource</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">resource</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
    </section>
  
  </section>
</main>


<footer id="validator-badges" role="contentinfo">
  <p><a href="http://validator.w3.org/check/referer">Validate</a>
  <p>Generated by <a href="http://rdoc.rubyforge.org">RDoc</a> 4.1.2.
  <p>Based on <a href="http://deveiate.org/projects/Darkfish-Rdoc/">Darkfish</a> by <a href="http://deveiate.org">Michael Granger</a>.
</footer>

